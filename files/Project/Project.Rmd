---
title: " IE 360 Project: Trendyol Products Sales Forecasting "
author: " Seyma Cakir - 2017402024 Oya Hoban - 2018402150 Ozlem SENEL - 2017402117 "
date:  " 2021-06-06 " 
output:
 html_document:
   toc: true
   toc_float: true
   smooth_scroll : true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set( echo = FALSE, warning = FALSE, message = FALSE)
```


```{r}
# install the required packages first
require(jsonlite)
require(httr)
require(data.table)
library(lubridate)
library(data.table)
library(dplyr)
library(ggplot2)
library(knitr)
library(tidyr)
library(tidyverse)
library(scales)
library(ggcorrplot)
library(forecast)
library(urca)
library(zoo)
library(reshape)
library(GGally)
library(PerformanceAnalytics)
library(gridExtra)
library(corrplot)


get_token <- function(username, password, url_site){
  
  post_body = list(username=username,password=password)
  post_url_string = paste0(url_site,'/token/')
  result = POST(post_url_string, body = post_body)
  
  # error handling (wrong credentials)
  if(result$status_code==400){
    print('Check your credentials')
    return(0)
  }
  else if (result$status_code==201){
    output = content(result)
    token = output$key
  }
  
  return(token)
}

get_data <- function(start_date='2020-03-20', token, url_site){
  
  post_body = list(start_date=start_date,username=username,password=password)
  post_url_string = paste0(url_site,'/dataset/')
  
  header = add_headers(c(Authorization=paste('Token',token,sep=' ')))
  result = GET(post_url_string, header, body = post_body)
  output = content(result)
  data = data.table::rbindlist(output)
  data[,event_date:=as.Date(event_date)]
  data = data[order(product_content_id,event_date)]
  return(data)
}


send_submission <- function(predictions, token, url_site, submit_now=F){
  
  format_check=check_format(predictions)
  if(!format_check){
    return(FALSE)
  }
  
  post_string="list("
  for(i in 1:nrow(predictions)){
    post_string=sprintf("%s'%s'=%s",post_string,predictions$product_content_id[i],predictions$forecast[i])
    if(i<nrow(predictions)){
      post_string=sprintf("%s,",post_string)
    } else {
      post_string=sprintf("%s)",post_string)
    }
  }
  
  submission = eval(parse(text=post_string))
  json_body = jsonlite::toJSON(submission, auto_unbox = TRUE)
  submission=list(submission=json_body)
  
  print(submission)
  # {"31515569":2.4,"32737302":2.4,"32939029":2.4,"4066298":2.4,"48740784":2.4,"6676673":2.4, "7061886":2.4, "73318567":2.4, "85004":2.4} 
  
  if(!submit_now){
    print("You did not submit.")
    return(FALSE)      
  }
  
  
  header = add_headers(c(Authorization=paste('Token',token,sep=' ')))
  post_url_string = paste0(url_site,'/submission/')
  result = POST(post_url_string, header, body=submission)
  
  if (result$status_code==201){
    print("Successfully submitted. Below you can see the details of your submission")
  } else {
    print("Could not submit. Please check the error message below, contact the assistant if needed.")
  }
  
  print(content(result))
  
}

check_format <- function(predictions){
  
  if(is.data.frame(predictions) | is.data.frame(predictions)){
    if(all(c('product_content_id','forecast') %in% names(predictions))){
      if(is.numeric(predictions$forecast)){
        print("Format OK")
        return(TRUE)
      } else {
        print("forecast information is not numeric")
        return(FALSE)                
      }
    } else {
      print("Wrong column names. Please provide 'product_content_id' and 'forecast' columns")
      return(FALSE)
    }
    
  } else {
    print("Wrong format. Please provide data.frame or data.table object")
    return(FALSE)
  }
  
}

# this part is main code
subm_url = 'http://46.101.163.177'

u_name = "Group3"
p_word = "LaQjwxkIGSGhBrRj"
submit_now = TRUE

username = u_name
password = p_word

token = get_token(username=u_name, password=p_word, url=subm_url)
data = get_data(token=token,url=subm_url)

#predictions=unique(data[,list(product_content_id)])
#predictions[,forecast:= c(224,110,122,494,2,474,22,62,56)]

#send_submission(predictions, token, url=subm_url, submit_now=T)

```



```{r}

# join  data 
rawdata <- read.csv("C:/Users/seyma/OneDrive/Belgeler/GitHub/spring21-seymacakir/files/project/ProjectRawData.csv", header = TRUE,sep = ",")
rawdata <- as.data.table(rawdata)
colnames <- c( "price","event_date","product_content_id","sold_count" , "visit_count" , "favored_count" , "basket_count","category_sold",     "category_brand_sold", "category_visits"  ,   "ty_visits"  ,  "category_basket",    "category_favored" )
rawdata <- rawdata[,..colnames]
rawdata <- rawdata[!is.na(sold_count)]
rawdata$event_date <- as.Date(rawdata$event_date, format = "%Y-%m-%d")
#rawdata$product_content_id <- as.factor(rawdata$product_content_id)
#data$product_content_id <- as.factor(data$product_content_id)



rawdata <- rbind(rawdata,data) %>% distinct(event_date, product_content_id, .keep_all = TRUE ) %>% arrange(event_date) %>% as.data.table()
 

forecastdata <- tail(rawdata,9) 
forecastdata[, event_date := as.Date(tail(rawdata,9)$event_date + 1)]

rawdata <- rbind(rawdata,forecastdata) %>% distinct(event_date, product_content_id, .keep_all = TRUE ) %>% arrange(event_date) %>% as.data.table()

 # add  month and weekday  component data 

rawdata[,w_day:= wday(event_date)]
rawdata[,mon:= month(event_date)]

forecastdata[,w_day:= wday(event_date)]
forecastdata[,mon:= month(event_date)]


# campaign 

rawdata[, is_campaign := 0]
rawdata[rawdata$event_date >= as.Date("2021-05-07") & rawdata$event_date <= as.Date("2021-05-09"), is_campaign := 1]
rawdata[rawdata$event_date >= as.Date("2020-06-18") & rawdata$event_date <= as.Date("2020-06-20") , is_campaign := 1]
rawdata[rawdata$event_date >= as.Date("2021-06-18") & rawdata$event_date <= as.Date("2021-06-20") , is_campaign := 1]
rawdata[rawdata$event_date >= as.Date("2020-09-08") & rawdata$event_date <= as.Date("2020-09-12") , is_campaign := 1]
rawdata[rawdata$event_date >= as.Date("2021-09-10") & rawdata$event_date <= as.Date("2021-09-12") , is_campaign := 1]
rawdata[rawdata$event_date >= as.Date("2020-11-09") & rawdata$event_date <= as.Date("2020-11-11") , is_campaign := 1]
rawdata[rawdata$event_date >= as.Date("2020-11-25") & rawdata$event_date <= as.Date("2020-11-29") , is_campaign := 1]
rawdata[rawdata$event_date >= as.Date("2021-03-09") & rawdata$event_date <= as.Date("2021-03-12") , is_campaign := 1]
rawdata[rawdata$event_date >= as.Date("2021-04-27") & rawdata$event_date <= as.Date("2021-04-29") , is_campaign := 1]
rawdata[rawdata$event_date >= as.Date("2021-06-09") & rawdata$event_date <= as.Date("2021-06-10") , is_campaign := 1]
rawdata[rawdata$event_date >= as.Date("2020-12-21") & rawdata$event_date <= as.Date("2020-12-24") , is_campaign := 1]





# create data table for each product

product_id <- unique(rawdata$product_content_id)
products <- list()
for ( i in 1:length(product_id)){
products[[i]] <- as.data.table(rawdata[product_content_id == product_content_id[i]])
}


```










```{r, functions}


# product 7 

forecast_lm7=function(data,forecast_data){
    fitted_lm=lm(sold_count ~ price  + visit_count + basket_count + category_basket  + factor(mon) +  factor(is_campaign) + trend + lag1 + lag3 , data)
    forecasted=predict(fitted_lm,forecast_data)
    return(list(forecast=as.numeric(forecasted),model=fitted_lm))
}


forecast_lm7_sqrt=function(data,forecast_data){
    fitted_lm=lm(sqrt~   price  + visit_count  + basket_count + ty_visits  + factor(mon)  + lag1 + lag7   + factor(is_campaign) + category_basket, data)
    forecasted=predict(fitted_lm,forecast_data)
    return(list(forecast=as.numeric(forecasted),model=fitted_lm))
}

forecast_BoxCox7=function(data,forecast_data){
    fitted_lm=lm(BoxCox~ price + visit_count  + basket_count + category_sold + ty_visits  + factor(mon) + lag1 + lag7  + factor(is_campaign)  + category_basket , data)
   forecasted=predict(fitted_lm,forecast_data)
    return(list(forecast=as.numeric(forecasted),model=fitted_lm))
}




forecast_lm7_arima <- function(data,forecast_data){
fitted_lm=lm(sold_count ~ price  + visit_count + basket_count + category_basket  + factor(mon) +  factor(is_campaign) + trend + lag1 + lag3 , data)
ur.kpss(residuals(fitted_lm))
residuals= ts( residuals(fitted_lm), frequency = 7)
fitted_arima <- auto.arima(residuals)

forecasted <- as.numeric(predict(fitted_lm,forecast_data)) + predict(fitted_arima, n.ahead = 1)$pred[1]
return(forecasted)
}


# product 8 


forecast_lm8=function(data,forecast_data){
    fitted_lm=lm( sold_count ~ price +   visit_count + basket_count + category_favored  +  factor( w_day )  + factor(mon)  + lag1 + lag2 + price_lag_1 +price_lag_4 ,data)
    forecasted=predict(fitted_lm,forecast_data)
    return(list(forecast=as.numeric(forecasted),model=fitted_lm))
}


forecast_lm8_sqrt=function(data,forecast_data){
    fitted_lm=lm(sqrt ~ price + visit_count  + basket_count +  category_favored + factor(w_day) + factor(mon) + lag1,data)
    forecasted=predict(fitted_lm,forecast_data)
    return(list(forecast=as.numeric(forecasted),model=fitted_lm))
}

forecast_BoxCox8=function(data,forecast_data){
    fitted_lm=lm(BoxCox~ price + visit_count  +  basket_count  + category_favored + factor( w_day ) + factor(mon) + lag1, data)
    forecasted=  forecasted=predict(fitted_lm,forecast_data)
    return(list(forecast=as.numeric(forecasted),model=fitted_lm))
}


forecast_lm8_arima <- function(data,forecast_data){
fitted_lm=lm( sold_count ~ price +   visit_count + basket_count + category_favored  +  factor( w_day )  + factor(mon)  + lag1 + lag2 + price_lag_1 +price_lag_4 ,data)
#ur.kpss(residuals(fitted_lm))
residuals= ts( residuals(fitted_lm), frequency = 7)
fitted_arima <- auto.arima(residuals)

forecasted <- predict(fitted_lm,forecast_data) + predict(fitted_arima, n.ahead = 1)$pred[1]
return(forecasted)
}


# product 9 

forecast_lm9=function(data,forecast_data){
    fitted_lm=lm( sold_count ~ price  + basket_count  + category_sold  + category_favored  + factor(w_day)  + factor(mon) + trend  +   lag1 +  lag3  + factor(is_campaign),data)
    forecasted=predict(fitted_lm,forecast_data)
    return(list(forecast=as.numeric(forecasted),model=fitted_lm))
}


forecast_lm9_sqrt=function(data,forecast_data){
    fitted_lm=lm(sqrt ~  price  +  basket_count  + category_sold  + category_favored + factor(w_day)  + factor(mon)  +   lag1 +  lag3 + factor(is_campaign),data)
    forecasted=predict(fitted_lm,forecast_data)
    return(list(forecast=as.numeric(forecasted),model=fitted_lm))
}

forecast_BoxCox9=function(data,forecast_data){
    fitted_lm=lm(BoxCox~ price    +  basket_count  + category_sold  + category_favored   + ty_visits + factor(w_day)  + factor(mon)  + factor(is_campaign)+   lag1 +  lag3, data)
    forecasted=  forecasted=predict(fitted_lm,forecast_data)
    return(list(forecast=as.numeric(forecasted),model=fitted_lm))
}


forecast_lm9_arima <- function(data,forecast_data){
 fitted_lm=lm( sold_count ~ price  + basket_count  + category_sold  + category_favored  + factor(w_day)  + factor(mon) + trend  +   lag1 +  lag3  + factor(is_campaign),data)
#ur.kpss(residuals(fitted_lm))
residuals= ts( residuals(fitted_lm), frequency = 7)
fitted_arima <- auto.arima(residuals)

forecasted <- predict(fitted_lm,forecast_data) + predict(fitted_arima, n.ahead = 1)$pred[1]
return(forecasted)
}



# common functions 


accu=function(actual,forecast,model){
  model = model
  n=length(actual)
  error=actual-forecast
  mean=mean(actual)
  sd=sd(actual)
  CV=sd/mean
  FBias=sum(error)/sum(actual)
  MAPE=sum(abs(error/actual))/n
  RMSE=sqrt(sum(error^2)/n)
  MAD=sum(abs(error))/n
  MADP=sum(abs(error))/sum(abs(actual))
  WMAPE=MAD/mean
  l=data.frame(model,n,mean,sd,CV,FBias,MAPE,RMSE,MAD,MADP,WMAPE)
  return(l)
}




graph1 <- function(i){
    
g1 <-ggplot(products[[i]], aes( x = event_date, y = sold_count)) + geom_line() + ggtitle(paste("product",i)) +theme_minimal()  
g2 <-ggplot(products[[i]], aes( y = sold_count, fill= factor(w_day))) + geom_boxplot() + 
  ggtitle(paste("product",i))+ theme_minimal() 
g3 <-ggplot(products[[i]], aes( y = sold_count, fill= factor(mon))) + geom_boxplot()+
      ggtitle(paste("product",i))+ theme_minimal() 
g4 <- ggplot(products[[i]], aes( x = sold_count)) + geom_histogram() + ggtitle(paste("product",i)) + theme_minimal()+
        facet_wrap(~factor(w_day))
g5 <-ggplot(products[[i]], aes( x = sold_count )) + geom_histogram() + theme_minimal()+ ggtitle(paste("product",i))+
      facet_wrap(~factor(mon))

print(g1)

grid.arrange(
  g2,g4,g3,g5,
  ncol = 2

)

ACF <- acf( products[[i]]$sold_count, plot = FALSE)
plot(ACF, main = paste("ACF OF Product",i))
PACF <- pacf( products[[i]]$sold_count, plot = FALSE)
plot(PACF, main = paste("PACF OF Product",i))
}


corr_graph <- function(data){
  df1 <- data[, c(4,1,5,6,7,11)]
  df2 <- data[, c(4,8:10,12,13)]
chart.Correlation(df1, pch=19)
chart.Correlation(df2, pch=19)

}


add_arima=function(data,h,f){
 ts <- ts(data$sold_count,frequency =f )
 add <- decompose(ts, type = "add") 
 fitted <- auto.arima(add$random, seasonal= FALSE)
 seasonal <- add$seasonal[(length(data$sold_count)-f): (length(data$sold_count)-f+h-1)]
 trend <- tail(add$trend[!is.na(add$trend)],1)
 forecastted <- as.numeric(forecast(fitted,h)$mean) + seasonal + trend
 return(forecastted)
}

xreg_add_arima=function(data,h,f, xreg){
 ts <- ts(data$sold_count,frequency =f )
 add <- decompose(ts, type = "add") 
 train_xreg<- xreg[1:length(data$event_date)]
 for_xreg <- xreg[(length(data$event_date))]
 fitted <- auto.arima(add$random, seasonal= FALSE, xreg = train_xreg)
 seasonal <- add$seasonal[(length(data$sold_count)-f): (length(data$sold_count)-f+h-1)]
 trend <- tail(add$trend[!is.na(add$trend)],1)
 forecastted <- as.numeric(forecast(fitted,h,xreg = for_xreg)$mean) + seasonal + trend
 return(forecastted)
}



mul_arima=function(data,h,f){
 
 ts <- ts(data$sold_count,frequency =f )
 mul <- decompose(ts, type = "mul") 
 fitted <- auto.arima(mul$random, seasonal= FALSE)
 seasonal <- mul$seasonal[(length(data$sold_count)-f): (length(data$sold_count)-f+h-1)]
 trend <- tail(mul$trend[!is.na(mul$trend)],1)
 forecasted <- as.numeric(forecast(fitted,h)$mean)*seasonal*trend
 return(forecasted)
}

xreg_mul_arima=function(data,h,f, xreg){
 ts <- ts(data$sold_count,frequency =f )
 mul <- decompose(ts, type = "mul") 
 train_xreg<- xreg[1:length(data$event_date)]
 for_xreg <- xreg[(length(data$event_date)) ]
 fitted <- auto.arima(mul$random, seasonal= FALSE, xreg = train_xreg)
 seasonal <- mul$seasonal[(length(data$sold_count)-f): (length(data$sold_count)-f+h-1)]
 trend <- tail(mul$trend[!is.na(mul$trend)],1)
 forecastted <- as.numeric(forecast(fitted,h,xreg = for_xreg)$mean)*seasonal*trend
 return(forecastted)
}


```


### Product 7 

**Oral-B Rechargeable ToothBrush**

First of all, the general behaviour of data is examined during the day by time plot. 

Secocondly, the distribution in days and months is plotted to see if it is changed depend on month and day. 

Finally , by ACF and PACF graph, the relationship between previous observations is observed. 

```{r}
product7 <- products[[7]]
graph1(7)

```

It can be say that, there is a trend in data, and if trend factor is excluded, the autocorrelation between lag1, lag3 and lag is significant. 

The data is depend on month and day factor by observing boxplot of data. Since the day factor is significant, day factor will be used in model construction instead of lag7 and the frequency of data determined as 7. 


**Examination of Attributes**

The some of the attributes of data is not reliable, therefore, it is examined by summary of data.

```{r}

summary(product7)

df <- product7[,c(1,4:14)]
do.call("cbind",lapply(df,function(x) boxplot.stats(x)$stats))



product7[is.na(price)]$price <- mean(product7[!is.na(price)]$price)
product7[,trend := 1:.N]
product7[ty_visits==1, ty_visits:= mean(ty_visits)]
product7[category_favored==0, category_favored:= mean(category_favored)]
product7[category_visits==0, category_visits:= mean(category_visits)]


corr_graph(product7)
```




The relationship of attributes and response variable is observed by correlation grapgh. 

Basket_count, category_visits and category_favored has high correlation and it seems reliable data from summary of data.However, there is 0 values which is not expected in real life therefore, the zero values are changed as mean. 

ty_visits also has 1 value before particular date and it is changed as mean of ty_visits. 

Some price values are NA, and they are changed as mean of price since price is not has significant changes during the time. 

In the end, "price","visit_count",  "basket_count","category_favored" , "ty_visits","is_campaign" values determined as regressors. 


```{r}

xreg7 <- product7[ , c( "price","visit_count",  "basket_count","category_favored" , "ty_visits","is_campaign")]
xreg7 <- as.matrix(xreg7)

```




```{r}

product7 [, lag1:= shift(sold_count,1)]
product7[is.na(lag1), lag1 := 0]
product7 [, lag2:= shift(sold_count,2)]
product7[is.na(lag2), lag2 := mean(sold_count[1]) ]
product7 [, lag3:= shift(sold_count,3)]
product7[is.na(lag3), lag3 := mean(sold_count[1:2]) ]
product7 [, lag7:= shift(sold_count,7)]
product7[is.na(lag7), lag7 := mean(sold_count[1:6]) ]



product7[, sqrt:= sqrt(sold_count)]
lambda <- BoxCox.lambda(product7$sold_count)
product7[, BoxCox := BoxCox(sold_count,lambda = lambda)]

test_dates <- tail(product7,15)$event_date
nextday <- tail(product7,1)
train7 <-  product7[!(event_date %in% test_dates)]
test_dates <- test_dates[1:14]
test7 <- product7[event_date %in% test_dates][1:14]

forecast_ahead <- 1
```

the data will be predicted based on previous observations attributes since the real attributes not available for prediction time. 



**model construction** 

the data has no constant variance therefore, besides the simple linear model, the sqrt transformation and boxcox tranformation is used for simple regression model


**simple linear regression with no transformation** 
By many iterations, it is seen that day factor is not significant as is expected. 

```{r}
autoplot(ts(product7$sold_count))
lm7 <- lm( sold_count ~ price  + visit_count + basket_count + category_basket  + factor(mon) +  factor(is_campaign) + trend + lag1 + lag3 , train7)
summary(lm7)
checkresiduals(lm7)

plot(train7$sold_count, lm7$fitted)
ggplot() + geom_line(data = train7, aes(x = event_date, y = sold_count,color = "Actual")) + geom_line( aes( x = train7$event_date,y = lm7$fitted,color = "Fitted")) + labs(
  x= "sales",
  y= "sales",
  main = "Actual vs. Fitted Values for LM model"
) + theme_minimal()
```

the residuals analysis is good for lm model with no significant autocorrelation around mean zero, however, the variablity of error in higher values is higher. 


**simple linear regression with sqrt() transformation** 

By many iterations, the 

```{r}
autoplot(ts(product7$sqrt))
sqrt_lm7 <- lm(sqrt~  price  + visit_count  + basket_count + ty_visits  + factor(mon)  + lag1  + factor(is_campaign) + category_visits + category_basket , train7 )
summary(sqrt_lm7)
checkresiduals(sqrt_lm7)

ggplot() + geom_line(data = train7, aes(x = event_date, y = sold_count, color = "Actual")) + geom_line( aes( x = train7$event_date,y = (sqrt_lm7$fitted)^2, color = "Fitted"))+ labs(
  x= "sales",
  y= "sales",
  main = "Actual vs. Fitted Values for LM model with sqrt() transformation"
) + theme_minimal()
```
the residuals analysis is  model with  significant autocorrelation in lag1 around mean zero, however, the variablity of error in higher values is higher. It is poor by comparing lm model with no transformation. 




**simple linear regression with BoxCox transformation** 


By many iterations, it is seen that day factornot significant but lag7 is significant and lag3 factor is not significant for boxcox linear model therefore, they excluded and the category_basket is significant for boxcox transformation. 

```{r}

BoxCox_lm7 <- lm(BoxCox~ price + visit_count  + basket_count + category_favored + ty_visits  + factor(mon) + lag1 + lag7 + factor(is_campaign)  + category_basket , train7)
summary(BoxCox_lm7)
autoplot(ts(product7$BoxCox))
checkresiduals(BoxCox_lm7)


ggplot() + geom_line(data = train7, aes(x = event_date, y = sold_count, color = "Actual")) + geom_line( aes( x = train7$event_date,y = InvBoxCox(BoxCox_lm7$fitted, lambda = lambda), color = "Fitted"))+ labs(
  x= "sales",
  y= "sales",
  main = "Actual vs. Fitted Values for LM model with BoxCox transformation"
) + theme_minimal()


```

By residuals analysis, boxcox model has big deviation in time and adjusted R-squared value is lower than others. 



**Arima Models** 

When arima models is constructed, the auto.arima function is used, and in every day the auto.arima function is runs again. 
the seasonality is TRUE, and frequency is determined as seven by observing ACF and PACF graph. 

Additive Model, Multplive Model, and linear regression model is used for decomposition and get stationary data. 

```{r}
print("The Additive Model")
decomposed <- decompose(ts(product7$sold_count,frequency= 7))
ur.kpss(decomposed$random)

print("The Multiplicative Model")
ur.kpss(decompose(ts(product7$sold_count,frequency= 7), type="mul")$random)

print("Linear Regression")
residuals <- residuals(lm7)
ur.kpss(residuals)

decomposed <- decompose(ts(train7$sold_count,frequency= 7))
``` 
the multiplive model is not significant, therefore I will use the addtive decomposition for arima and arima regressors models.

the linear regression model residuals are stationary therefore, the residuals use for arima model and they combined in the end. 

the regressors mentioned above is used for arima model with regressors. 



```{r}
acf(decomposed$random, lag = 14, na.action = na.pass)
pacf(decomposed$random, lag = 14, na.action = na.pass)
arima <- auto.arima(decomposed$random) 
arima

checkresiduals(arima)

 pred <- arima$fitted + decomposed$seasonal + decomposed$trend
 
 
 
 ggplot() + geom_line(aes( x= train7[1:length(pred)]$event_date, y= train7[1:length(pred)]$sold_count, color= "Actual")) + geom_line(aes( x= train7[1:length(pred)]$event_date, y= pred, color= "Predicted")) + labs(
   x= "time", 
   y= "sales", 
   main = "Actual vs. Predicted Values for arima(0,0,1)(0,0,2)[7]"
 ) + theme_minimal()
```
By observing, pacf is significant at lag1 and acf drops after lag1 therfore, it is reasonable auto.arima gives the MA(1). 
And at lag2 as seasonal the pacf and acf is significant, the seasonal order(0,0,2) is reasonable, too. 

```{r}

reg_arima <- auto.arima(decomposed$random, xreg = xreg7[1:(length(decomposed$random))]) 
reg_arima

checkresiduals(reg_arima)
AIC(reg_arima)

 pred <- reg_arima$fitted + decomposed$seasonal + decomposed$trend
 
 
 
 ggplot() + geom_line(aes( x= train7[1:length(pred)]$event_date, y= train7[1:length(pred)]$sold_count, color= "Actual")) + geom_line(aes( x= train7[1:length(pred)]$event_date, y= pred, color= "Predicted"))+ labs(
   x= "time", 
   y= "sales", 
   main = "Actual vs. Predicted Values for arima model with regressors"
 ) + theme_minimal()


```
By residual analysis, the arima with regressors has no autocorrelated residuals and lower AIC, therefore arima with regressors is better model than arima. 

**Arima combined with linear Regression**

```{r}
acf(residuals)
pacf(residuals)
lm_arima <- auto.arima(residuals)
lm_arima
checkresiduals(lm_arima)

 pred <- lm_arima$fitted + lm7$fitted.values
 
 
 ggplot() + geom_line(aes( x= train7$event_date, y= train7$sold_count, color= "Actual")) + geom_line(aes( x= train7$event_date, y= pred, color= "Predicted"))+ labs(
   x= "time", 
   y= "sales", 
   main = "Actual vs. Predicted Values for linear model and arima combination"
 )  + theme_minimal()

```
the auto arima model on residuals give zero mean and no autocorrelated residuals and lower AIC valu, it is better than arima and arima regressor model by residual analysis. 




**Predictions**

The predictions based on the last available attributes, and the predictions plotted with actual sales values. 

```{r}



prediction7 <- data.table("event_date" = test_dates,"actual"= product7[event_date %in% test_dates]$sold_count, "sqrt_forecasted_sold"= c(1:length(test_dates)), "BoxCox_forecasted_sold"= c(1:length(test_dates)), "lm_forecasted_sold"= c(1:length(test_dates)), "forecasted_lm7_arima"= c(1:length(test_dates)) )


prediction7[, add_arima_forecasted := 0]

prediction7[, reg_add_arima_forecasted := 0]





for(i in 1:length(test_dates)){
    current_date=test_dates[i]-forecast_ahead
    past_data=product7[event_date<=current_date]
    forecast_data=product7[event_date==test_dates[i]]
    
    forecasted=forecast_lm7_sqrt(past_data,forecast_data)
    prediction7$sqrt_forecasted_sold[i]<- forecasted$forecast^2
    
    forecasted=forecast_BoxCox7(past_data,forecast_data)
    prediction7$BoxCox_forecasted_sold[i]<- InvBoxCox(forecasted$forecast, lambda = lambda)
    
    forecasted=forecast_lm7(past_data,forecast_data)
    prediction7$lm_forecasted_sold[i]<- forecasted$forecast
    
    prediction7$forecasted_lm7_arima[i] <- forecast_lm7_arima(past_data,forecast_data)
    
    
    prediction7$add_arima_forecasted[i] <- add_arima(past_data,1,7)
    prediction7$reg_add_arima_forecasted[i] <- xreg_add_arima(past_data,1,7,xreg7)
   
}

prediction7

  

```
```{r}

ggplot() + geom_line(data = product7[event_date %in% test_dates], aes(x= event_date, y = sold_count)) + 
  geom_line(data = prediction7,aes( x = event_date,y =sqrt_forecasted_sold, color = "Sqrt"))+ 
   geom_line(data = prediction7,aes( x = event_date,y =lm_forecasted_sold, color = "No Transformation")) + 
   geom_line(data = prediction7,aes( x = event_date,y =BoxCox_forecasted_sold, color = "BoxCox")) +
   geom_line(data = prediction7,aes( x = event_date,y =forecasted_lm7_arima, color = " lm_arima")) +
   geom_line(data = prediction7,aes( x = event_date,y = add_arima_forecasted, color = "add_arima_forecasted"))+ 

   geom_line(data = prediction7,aes( x = event_date,y = reg_add_arima_forecasted, color = "reg_add_arima_forecasted"))+ 
  
  labs(
    x= "time",
    y= "sales",
    main= "Predictions vs. Actual Values"
  ) + 
  theme_minimal()
```


**EROR rate of Models**

```{r}
  
error7 =  data.table()

for(i in 3:(length(prediction7))){
  

  error7 <- rbind(error7, accu(test7$sold_count,prediction7[,..i],colnames(prediction7[,..i])))
}


error7


```

Since the arima model combined model has the lowest WMAPE value it is selected for prediction. 
However, 
In every day, the error rates are calculated for last 14 days and the model predictions and the model prediction has the lowest  WMAPE value of is selected.



**Predictions of Next Day** 



```{r}

nextday_pred <-c(

"add_arima" = add_arima(product7,1,7),
"xreg_add_arima" = xreg_add_arima(product7,1,7, xreg7),
"forecast_lm" =forecast_lm7(product7,nextday)$forecast,
"forecast_lm_arima" = forecast_lm7_arima(product7,nextday)[1],
"BoxCox_lm" = InvBoxCox(forecast_BoxCox7(product7,nextday)$forecast, lambda = lambda),
"Sqrt_lm" = round((forecast_lm7_sqrt(product7,nextday)$forecast)^2)


)


nextday_pred

```


### Product 8 

**Altinyildiz Classics Jacket**

```{r}
product8 <- products[[8]]
graph1(8)
```

It can be seen that the sales is zero most of time, however, there is huge increase in October. 

The ACF and PACF of data shows that there is significant autocorrelation in lag1 and lag7. 



**the Examination of Attirubutes**

the correlation of price, visit_count, and basket_count is high and it is expected if the sold_count is zero this variables can be zero. 

However, it is not expected that category favored and trendyol visits is zero or one therefore these variables changed as mean. 

```{r}


summary(product8)

df <- product8[,c(1,4:14)]
do.call("cbind",lapply(df,function(x) boxplot.stats(x)$stats))

corr_graph(product8)

product8[is.na(price)]$price <- mean(product7[!is.na(price)]$price)
product8[,trend :=1:.N]
product8[ty_visits ==1 , ty_visits:= round(mean(product8$ty_visits))]
product8[category_basket==0,  category_basket:= round(mean(product8$category_basket))]
product8[category_basket > 469103  ,  category_basket:= round(mean(product8$category_basket))]


```

By considering correlation and variable relaibility the "price","visit_count",  "basket_count","category_favored"  are selected as regressors. 

```{r}

xreg8 <- product8[ , c( "price","visit_count",  "basket_count","category_favored" )]
xreg8 <- as.matrix(xreg8)
```



The acf and pacf garph is shows high correlation in lag1,lag2,lag5 and lag7 therefore they are added as attirbutes. 

```{r}

product8 [, lag1:= shift(sold_count,1)]
product8[is.na(lag1), lag1 := 0]
product8 [, lag2:= shift(sold_count,2)]
product8[is.na(lag2), lag2 := mean(sold_count[1]) ]
product8 [, lag5:= shift(sold_count,5)]
product8[is.na(lag5), lag5 := mean(sold_count[1:4]) ]
product8 [, lag7:= shift(sold_count,7)]
product8[is.na(lag7), lag7 := mean(sold_count[1:6]) ]
```


Since Jacket is expensive product, it is expected that consumers consider the previous price of jacket. Therefore, previous prices of Jacket is examined. 

```{r}
product8[ , price_lag_4 := shift(price,4)]
product8[ , price_lag_5 := shift(price,5)]
product8[ , price_lag_6 := shift(price,6)]
product8[ , price_lag_1 := shift(price,1)]
product8[is.na(price_lag_4), price_lag_4:= mean(price) ]
product8[is.na(price_lag_5), price_lag_5:= mean(price) ]
product8[is.na(price_lag_6), price_lag_6:= mean(price) ]
product8[is.na(price_lag_1), price_lag_1:= mean(price) ]

corr <- product8[, c("sold_count","price", "price_lag_1","price_lag_4","price_lag_5", "price_lag_6")]
corrplot(cor(corr), method="color",  
         type="upper", order="hclust", 
         addCoef.col = "black",
         tl.col="black", tl.srt=45, 
         
         diag=FALSE 
         )
```


the data will be predicted based on previous observations attributes since the real attributes not available for prediction time. 



**model construction** 

the data has no constant variance therefore, besides the simple linear model, the sqrt transformation and boxcox tranformation is used for simple regression model

```{r}

product8[, sqrt:= sqrt(sold_count)]
lambda <- BoxCox.lambda(product8$sold_count)
product8[, BoxCox := BoxCox(sold_count,lambda = lambda)]

test_dates <- tail(product8,15)$event_date
nextday <- tail(product8,1)
train8 <-  product8[!(event_date %in% test_dates)]
test_dates <- test_dates[1:14]
test8 <- product8[event_date %in% test_dates][1:14]


forecast_ahead <- 1
```

**Simple Regression**

By many iterations, it is seen that most significant variables are price, visit_count, basket_count, category_favored,factor( w_day ), factor(mon),lag1,lag2,price_lag_4. 



```{r}
autoplot(ts(product8$sold_count))
lm8 <- lm( sold_count ~ price +   visit_count + basket_count + category_favored  +  factor( w_day )  + factor(mon)  + lag1 + lag2  + price_lag_4, train8)
summary(lm8)
checkresiduals(lm8)


ggplot() + geom_line(data = train8, aes(x = event_date, y = sold_count, color = "Actual")) + geom_line( aes( x = train8$event_date,y = (lm8$fitted), color = "Fitted"))+ labs(
  x= "sales",
  y= "sales",
  main = "Actual vs. Fitted Values for LM model with no transformation"
) + theme_minimal()
```
**Simple Linear Regression with sqrt() transformation**

By many iteration, it is seen that the plag_4 and lag_2 is not significant for sqrt transformation model, lag5 is significant.  

```{r}

autoplot(ts(product8$sqrt))
sqrt_lm8 <- lm(sqrt ~ price + visit_count  + basket_count +  category_favored + factor(w_day) + factor(mon) + lag1 +lag5, data = train8)
summary(sqrt_lm8)
checkresiduals(sqrt_lm8)
ggplot() + geom_line(data = train8, aes(x = event_date, y = sold_count, color = "Actual")) + geom_line( aes( x = train8$event_date,y = (sqrt_lm8$fitted)^2, color = "Fitted"))+ labs(
  x= "sales",
  y= "sales",
  main = "Actual vs. Fitted Values for LM model with sqrt transformation"
) + theme_minimal()


```
 In residual analysis there is no significant difference, and adjusted R-square value of squared transformation is higher.


**Simple Linear Regression Model with BoxCox Transformation**
By many iteration, price, visit_count, basket_count, category_favored, factor( w_day ), factor(mon), lag1 are most significant variables for Simple Linear Regression Model with BoxCox Transformation. 



```{r}
autoplot(ts(product8$BoxCox))
BoxCox_lm8 <- lm(BoxCox~ price + visit_count  +  basket_count  + category_favored + factor( w_day ) + factor(mon) + lag1,train8)
summary(BoxCox_lm8)
checkresiduals(BoxCox_lm8)

ggplot() + geom_line(data = train8, aes(x = event_date, y = sold_count, color = "Actual")) + geom_line( aes( x = train8$event_date,y = InvBoxCox(BoxCox_lm8$fitted.values,lambda), color = "Fitted"))+ labs(
  x= "sales",
  y= "sales",
  main = "Actual vs. Fitted Values for LM model with sqrt transformation"
) + theme_minimal()



```
In residual analysis and adjusted R-squared comparison BoxCox is better than others, however, it is very sensitive to back transformation, therefore, maybe predictions can be poor. 


**Arima Models** 

When arima models is constructed, the auto.arima function is used, and in every day the auto.arima function is runs again. 
the seasonality is TRUE, and frequency is determined as seven by observing ACF and PACF graph. 

Additive Model, Multplive Model, and linear regression model is used for decomposition and get stationary data. 

```{r}
print("The Additive Model")
decomposed <- decompose(ts(product8$sold_count,frequency= 7))
ur.kpss(decomposed$random)

print("The Multiplicative Model")
ur.kpss(decompose(ts(product8$sold_count,frequency= 7), type="mul")$random)

print("Linear Regression")
residuals <- residuals(lm8)
ur.kpss(residuals)

decomposed <- decompose(ts(train8$sold_count,frequency= 7))
``` 

the multiplive model is significant at alpha level = .10, therefore I will use the addtive decomposition for arima and arima regressors models.

the linear regression model residuals are stationary therefore, the residuals use for arima model and they combined in the end. 

the regressors mentioned above is used for arima model with regressors. 

**Arima**

```{r}
acf(decomposed$random, lag = 14, na.action = na.pass)
pacf(decomposed$random, lag = 14, na.action = na.pass)
arima <- auto.arima(decomposed$random) 
arima

checkresiduals(arima)

 pred <- arima$fitted + decomposed$seasonal + decomposed$trend
 
 
 
 ggplot() + geom_line(aes( x= train8[1:length(pred)]$event_date, y= train8[1:length(pred)]$sold_count, color= "Actual")) + geom_line(aes( x= train8[1:length(pred)]$event_date, y= pred, color= "Predicted")) + labs(
   x= "time", 
   y= "sales", 
   main = "Actual vs. Predicted by Arima combined with Linear Regression"
 ) + theme_minimal()
```




**Arima with Regressor**

```{r}
reg_arima <- auto.arima(decomposed$random, xreg = xreg8[1:(length(decomposed$random))]) 
reg_arima

checkresiduals(reg_arima)


 pred <- reg_arima$fitted + decomposed$seasonal + decomposed$trend
 
 
 
 ggplot() + geom_line(aes( x= train8[1:length(pred)]$event_date, y= train8[1:length(pred)]$sold_count, color= "Actual")) + geom_line(aes( x= train8[1:length(pred)]$event_date, y= pred, color= "Predicted"))+ labs(
   x= "time", 
   y= "sales", 
   main = "Actual vs. Predicted Values for arima model with regressors"
 ) + theme_minimal()
```

**Arima combined with linear Regression**

```{r}

acf(residuals)
pacf(residuals)
lm_arima <- auto.arima(residuals)
lm_arima
checkresiduals(lm_arima)

 pred <- lm_arima$fitted + lm8$fitted.values
 
 
 ggplot() + geom_line(aes( x= train8$event_date, y= train8$sold_count, color= "Actual")) + geom_line(aes( x= train8$event_date, y= pred, color= "Predicted"))+ labs(
   x= "time", 
   y= "sales", 
   main = "Actual vs. Predicted Values for linear model and arima combination"
 )  + theme_minimal()

```




**Predictions**

The all models are used to predict include mul_arima and reg_mul_arima since they significant at alpha = 0.10. 

```{r}

prediction8 <- data.table("event_date" = test_dates,"actual"= product8[event_date %in% test_dates]$sold_count, "sqrt_forecasted_sold"= c(1:length(test_dates)), "BoxCox_forecasted_sold"= c(1:length(test_dates)), "lm_forecasted_sold"= c(1:length(test_dates)), "forecasted_lm8_arima"= c(1:length(test_dates)) )


prediction8[, add_arima_forecasted := 0]
prediction8[ , mul_arima_forecasted := 0]
prediction8[, reg_add_arima_forecasted := 0]
prediction8[ ,reg_mul_arima_forecasted := 0]




for(i in 1:length(test_dates)){
    current_date=test_dates[i]-forecast_ahead
    past_data=product8[event_date<=current_date]
    forecast_data=product8[event_date==test_dates[i]]
    
    forecasted=forecast_lm8_sqrt(past_data,forecast_data)
    prediction8$sqrt_forecasted_sold[i]<- round(forecasted$forecast^2)
    
    forecasted=forecast_BoxCox8(past_data,forecast_data)
    prediction8$BoxCox_forecasted_sold[i]<- round(InvBoxCox(forecasted$forecast, lambda = lambda))
    
    forecasted=forecast_lm8(past_data,forecast_data)
    prediction8$lm_forecasted_sold[i]<- round(forecasted$forecast)
    
    prediction8$forecasted_lm8_arima[i] <-round(forecast_lm8_arima(past_data,forecast_data))
    
    
    prediction8$add_arima_forecasted[i] <- round(add_arima(past_data,1,7))
    prediction8$reg_add_arima_forecasted[i] <- round(xreg_add_arima(past_data,1,7,xreg8))
    prediction8$mul_arima_forecasted[i] <- round(mul_arima(past_data,1,7))
    prediction8$reg_mul_arima_forecasted[i] <- round(xreg_mul_arima(past_data,1,7,xreg8))
}

prediction8


  

```

```{r}

ggplot() + geom_line(data = product8[event_date %in% test_dates], aes(x= event_date, y = sold_count)) + 
  geom_line(data = prediction8,aes( x = event_date,y =sqrt_forecasted_sold, color = "Sqrt"))+ 
   geom_line(data = prediction8,aes( x = event_date,y =lm_forecasted_sold, color = "No Transformation")) + 
   geom_line(data = prediction8,aes( x = event_date,y =BoxCox_forecasted_sold, color = "BoxCox")) +
   geom_line(data = prediction8,aes( x = event_date,y =forecasted_lm8_arima, color = " lm_arima")) +
   geom_line(data = prediction8,aes( x = event_date,y = add_arima_forecasted, color = "add_arima_forecasted"))+ 
   geom_line(data = prediction8,aes( x = event_date,y =mul_arima_forecasted, color = "mul_arima_forecasted")) +
   geom_line(data = prediction8,aes( x = event_date,y = reg_add_arima_forecasted, color = "reg_add_arima_forecasted"))+ 
   geom_line(data = prediction8,aes( x = event_date,y =reg_mul_arima_forecasted , color = "reg_mul_arima_forecasted"))+
   labs(
    x= "time",
    y= "sales",
    main= "Predictions vs. Actual Values"
  ) + 
  theme_minimal()
```




**EROR rates**

```{r}
  
error8 =  data.table()

for(i in 3:(length(prediction8))){
  

  error8 <- rbind(error8, accu(test8$sold_count,prediction8[,..i],colnames(prediction8[,..i])))
}


error8

```
The error rates are very high, however the range of response variable too narrow, therefore, it is expected. 
Like if the sales = 1 and the prediction is equal= 2 the error rate will be %100. 

The mul_arima_forecasted has the lowest error rate. 


**Next Day Prediction**
In every day, the error rates are calculated for last 14 days and the model predictions and the model prediction has the lowest  WMAPE value of is selected.

```{r}

nextday_pred <-c(

"add_arima" = add_arima(product8,1,7),
"mul_arima" = mul_arima(product8,1,7),
"xreg_mul_arima" = xreg_mul_arima(product8,1,7, xreg8),
"xreg_add_arima" = xreg_add_arima(product8,1,7, xreg8),
"forecast_lm" =forecast_lm8(product8,nextday)$forecast,
"forecast_lm_arima" = forecast_lm8_arima(product8,nextday)[1],
"BoxCox_lm" = InvBoxCox(forecast_BoxCox8(product8,nextday)$forecast, lambda = lambda),
"Sqrt_lm" = round((forecast_lm8_sqrt(product8,nextday)$forecast)^2)


)


nextday_pred

```


### Product9 

**TrendyolMilla Bikini Top**


By observing the graph below, the month effect is clearly observable. It is expected since bikini is wore in hot seasons in Turkey. 
Moreover, by examined the acf and pacf graph, it can be said that there is trend in data and correlation with lag1 and lag7. 

```{r}
product9 <- products[[9]]

graph1(9)
```


the "price","category_sold",  "basket_count","category_favored" attributes are more relaible and significantly corralet with data. Even if the visit_count and favored_count is very high corraleted with data, they also corraleted with basket_count therefore they do not used in regressors. 

```{r}
summary(product9)



product9[is.na(price)]$price <- mean(product9[(!is.na(price)) & (price>= 0) ]$price)
product9[price<=0]$price <- mean(product9[!is.na(price)]$price)

corr_graph(product9)


xreg9 <- product9[ , c( "price","category_sold",  "basket_count","category_favored" )]
xreg9 <- as.matrix(xreg9)

```


The trend, lag1,lag2,lag3, and lag7 variables are added data. 

```{r}
product9[,trend := 1:.N]

product9[ty_visits==1, ty_visits:= mean(ty_visits)]
product9 [, lag1:= shift(sold_count,1)]
product9[is.na(lag1), lag1 := 0]
product9 [, lag2:= shift(sold_count,2)]
product9[is.na(lag2), lag2 := mean(sold_count[1]) ]
product9 [, lag3:= shift(sold_count,3)]
product9[is.na(lag3), lag3 := mean(sold_count[1:2]) ]
product9 [, lag7:= shift(sold_count,7)]
product9[is.na(lag7), lag7 := mean(sold_count[1:6]) ]
```


**model construction** 

the data has no constant variance therefore, besides the simple linear model, the sqrt transformation and boxcox tranformation is used for simple regression model

```{r}

product9[, sqrt:= sqrt(sold_count)]
lambda <- BoxCox.lambda(product9$sold_count)
product9[, BoxCox := BoxCox(sold_count,lambda = lambda)]

test_dates <- tail(product9,15)$event_date
nextday <- tail(product9,1)
train9 <-  product9[!(event_date %in% test_dates)]
test_dates <- test_dates[1:14]
test9 <- product9[event_date %in% test_dates][1:14]



forecast_ahead <- 1

```


In product9, attributes are reliable therefore the all attributes are tried to add model and most significance ones selected for the model .



**simple linear regression with no transformation** 
 

```{r}

autoplot(ts(product9$sold_count))
lm9 <- lm( sold_count ~ price  +  visit_count    +  basket_count  + favored_count + category_sold + category_visits + category_basket + category_favored + category_brand_sold  + factor(w_day)  + factor(mon) + trend  +   lag1 +  lag3   ,train9 )
summary(lm9)
checkresiduals(lm9)

```

The Adjusted R-squared value is very high and residuals seems to no autocorraled arround the mean zero. The model is a can be good fit. 


```{r}

ggplot() + geom_line(data = train9, aes(x = event_date, y = sold_count, color = "Actual")) + geom_line( aes( x = train9$event_date,y = (lm9$fitted), color = "Fitted"))+ labs(
  x= "sales",
  y= "sales",
  main = "Actual vs. Fitted Values for LM model with no transformation"
) + theme_minimal()
```


**Simple Linear Regression Model with sqrt transformation**


```{r}
autoplot(ts(product9$sqrt))
sqrt_lm9 <- lm(sqrt~ price  +  visit_count    +  basket_count  + favored_count + category_sold + category_visits + category_basket + category_favored + category_brand_sold + ty_visits + factor(w_day)  + factor(mon)  +   lag1 +  lag3     , train9 )
summary(sqrt_lm9)
checkresiduals(sqrt_lm9)
```
The sqrt tranformation is also good fit model by R-squared value and residual analysis, However, it has lower R-squared value than no transformation model. 

```{r}

ggplot() + geom_line(data = train9, aes(x = event_date, y = sold_count, color = "Actual")) + geom_line( aes( x = train9$event_date,y = (sqrt_lm9$fitted)^2, color = "Fitted"))+ labs(
  x= "sales",
  y= "sales",
  main = "Actual vs. Fitted Values for LM model with sqrt() transformation"
) + theme_minimal()
```

**BoxCox Transformation**

```{r}

autoplot(ts(product9$BoxCox))
BoxCox_lm9 <- lm(BoxCox~price  +  visit_count    +  basket_count  + favored_count  + category_visits + category_basket  + ty_visits + factor(w_day)  + factor(mon)  +   lag1 +  lag3            
                , train9)
summary(BoxCox_lm9)
checkresiduals(BoxCox_lm9)

```

BoxCox transformation is also can be good fit model since the adjusted R-square value high. 


```{r}
ggplot() + geom_line(data = train9, aes(x = event_date, y = sold_count, color = "Actual")) + geom_line( aes( x = train9$event_date,y = InvBoxCox(BoxCox_lm9$fitted.values,lambda), color = "Fitted"))+ labs(
  x= "sales",
  y= "sales",
  main = "Actual vs. Fitted Values for LM model with BoxCox transformation"
) + theme_minimal()


```


In all lm models the residuals is significantly corraleted in lag1 it is not desirable. 


**Arima Models**


**Arima Models** 

When arima models is constructed, the auto.arima function is used, and in every day the auto.arima function is runs again. 
the seasonality is TRUE, and frequency is determined as seven by observing ACF and PACF graph. 

Additive Model, Multplive Model, and linear regression model is used for decomposition and get stationary data. 

```{r}
print("The Additive Model")
decomposed <- decompose(ts(product9$sold_count,frequency= 7))
ur.kpss(decomposed$random)

print("The Multiplicative Model")
ur.kpss(decompose(ts(product9$sold_count,frequency= 7), type="mul")$random)

print("Linear Regression")
residuals <- residuals(lm9)
ur.kpss(residuals)

decomposed <- decompose(ts(train9$sold_count,frequency= 7))
``` 

I used the addtive model in examination, however, the mul model is also used in predictions and calculated error rate since it is significant at level = 0.05




**Arima** 



```{r}
acf(decomposed$random, lag = 14, na.action = na.pass)
pacf(decomposed$random, lag = 14, na.action = na.pass)
arima <- auto.arima(decomposed$random) 
arima

checkresiduals(arima)

 pred <- arima$fitted + decomposed$seasonal + decomposed$trend
 
 
 
 ggplot() + geom_line(aes( x= train9[1:length(pred)]$event_date, y= train9[1:length(pred)]$sold_count, color= "Actual")) + geom_line(aes( x= train9[1:length(pred)]$event_date, y= pred, color= "Predicted")) + labs(
   x= "time", 
   y= "sales", 
   main = "Actual vs. Predicted by Arima combined with Linear Regression"
 ) + theme_minimal()
```





**Arima with Regressor** 



```{r}
reg_arima <- auto.arima(decomposed$random, xreg = xreg9[1:(length(decomposed$random))]) 
reg_arima

checkresiduals(reg_arima)


 pred <- reg_arima$fitted + decomposed$seasonal + decomposed$trend
 
 
 
 ggplot() + geom_line(aes( x= train9[1:length(pred)]$event_date, y= train9[1:length(pred)]$sold_count, color= "Actual")) + geom_line(aes( x= train9[1:length(pred)]$event_date, y= pred, color= "Predicted"))+ labs(
   x= "time", 
   y= "sales", 
   main = "Actual vs. Predicted Values for arima model with regressors"
 ) + theme_minimal()
```






**Arima comined with Linear Regression**



```{r}

acf(residuals)
pacf(residuals)
lm_arima <- auto.arima(residuals)
lm_arima
checkresiduals(lm_arima)

 pred <- lm_arima$fitted + lm9$fitted.values
 
 
 ggplot() + geom_line(aes( x= train9[1:length(pred)]$event_date,  y= train9[1:length(pred)]$sold_count, color= "Actual")) + geom_line(aes(  x= train9[1:length(pred)]$event_date, y= pred, color= "Predicted"))+ labs(
   x= "time", 
   y= "sales", 
   main = "Actual vs. Predicted Values for linear model and arima combination"
 )  + theme_minimal()
```
















**Predictions**

```{r}


prediction9 <- data.table("event_date" = test_dates,"actual"= product9[event_date %in% test_dates]$sold_count, "sqrt_forecasted_sold"= c(1:length(test_dates)), "BoxCox_forecasted_sold"= c(1:length(test_dates)), "lm_forecasted_sold"= c(1:length(test_dates)), "forecasted_lm9_arima"= c(1:length(test_dates)) )


prediction9[, add_arima_forecasted := 0]
prediction9[ , mul_arima_forecasted := 0]
prediction9[, reg_add_arima_forecasted := 0]
prediction9[ ,reg_mul_arima_forecasted := 0]




for(i in 1:length(test_dates)){
    current_date=test_dates[i]-forecast_ahead
    past_data=product9[event_date<=current_date]
    forecast_data=product9[event_date==test_dates[i]]
    
    forecasted=forecast_lm9_sqrt(past_data,forecast_data)
    prediction9$sqrt_forecasted_sold[i]<- forecasted$forecast^2
    
    forecasted=forecast_BoxCox9(past_data,forecast_data)
    prediction9$BoxCox_forecasted_sold[i]<- InvBoxCox(forecasted$forecast, lambda = lambda)
    
    forecasted=forecast_lm9(past_data,forecast_data)
    prediction9$lm_forecasted_sold[i]<- forecasted$forecast
    
    prediction9$forecasted_lm9_arima[i] <- forecast_lm9_arima(past_data,forecast_data)
    
    
    prediction9$add_arima_forecasted[i] <- add_arima(past_data,1,7)
    prediction9$reg_add_arima_forecasted[i] <- xreg_add_arima(past_data,1,7,xreg9)
    prediction9$mul_arima_forecasted[i] <- mul_arima(past_data,1,7)
    prediction9$reg_mul_arima_forecasted[i] <-xreg_mul_arima(past_data,1,7,xreg9)
}



prediction9


```



```{r}

ggplot() + geom_line(data = product9[event_date %in% test_dates], aes(x= event_date, y = sold_count)) + 
  geom_line(data = prediction9,aes( x = event_date,y =sqrt_forecasted_sold, color = "Sqrt"))+ 
   geom_line(data = prediction9,aes( x = event_date,y =lm_forecasted_sold, color = "No Transformation")) + 
   geom_line(data = prediction9,aes( x = event_date,y =BoxCox_forecasted_sold, color = "BoxCox")) +
   geom_line(data = prediction9,aes( x = event_date,y =forecasted_lm9_arima, color = " lm_arima")) +
   geom_line(data = prediction9,aes( x = event_date,y = add_arima_forecasted, color = "add_arima_forecasted"))+ 
   geom_line(data = prediction9,aes( x = event_date,y =mul_arima_forecasted, color = "mul_arima_forecasted")) +
   geom_line(data = prediction9,aes( x = event_date,y = reg_add_arima_forecasted, color = "reg_add_arima_forecasted"))+ 
   geom_line(data = prediction9,aes( x = event_date,y =reg_mul_arima_forecasted , color = "reg_mul_arima_forecasted"))+
   labs(
    x= "time",
    y= "sales",
    main= "Predictions vs. Actual Values"
  ) + 
  theme_minimal()
```


**EROR RATES**



```{r}
error9 =  data.table()

for(i in 3:(length(prediction9))){
  

  error9 <- rbind(error9, accu(test9$sold_count,prediction9[,..i],colnames(prediction9[,..i])))
}


error9


```

**Next Day Prediction**

In every day, the error rates are calculated for last 14 days and the model predictions and the model prediction has the lowest  WMAPE value of is selected. 

```{r}
## forcast next day


nextday_pred <-c(

"add_arima" = add_arima(product9,1,7),
"mul_arima" = mul_arima(product9,1,7),
"xreg_mul_arima" = xreg_mul_arima(product9,1,7, xreg9),
"xreg_add_arima" = xreg_add_arima(product9,1,7, xreg9),
"forecast_lm" =forecast_lm9(product9,nextday)$forecast,
"forecast_lm_arima" = forecast_lm9_arima(product9,nextday)[1],
"BoxCox_lm" = InvBoxCox(forecast_BoxCox9(product9,nextday)$forecast, lambda = lambda),
"Sqrt_lm" = (forecast_lm9_sqrt(product9,nextday)$forecast)^2


)

nextday_pred

```




